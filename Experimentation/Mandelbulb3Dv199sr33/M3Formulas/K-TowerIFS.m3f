[OPTIONS]
.Version = 6
.DEoption = 20
.SSE2
.Double OTrapOffset = 0 
.2Doubles Scale = 2
.2Doubles Z add = 0
.Double Y add = 0
.2Doubles X add = 0
.Integer Apply scale+add = 0
.Double OTrapOnIts = 0.25
.3SingleAngles Rotate = 0 
.Double sinZmul = 4
.Double Thickness = .01
.Double XYmul = 4
.Double Kaleido = 1.5
[CONSTANTS]
Double = .16667
[CODE]
83C49C660F104688F20F104E98660F5947E0F20F594FE0660F5847C0F20F584F
D0837FBC007419F20F106E70F20F596FE0660F114688F20F114E98F20F116E70
660F110424F20F114C2410DD442410DD442408DD0424D9C0D84F90D9C2D84F8C
DEC1D9C3D84F88DEC1D9C1D84FA8D9C3D84FA4DEC1D9C4D84FA0DEC1D9CAD84F
9CD9CBD84F98DEC3D9CBD84F94DEC2DD1C24DD5C2408DD5C2410DD0424DD4424
08D9F3DC8F68FFFFFFD9FBDD5C2418DD5C2420DD0424D8C8DD442408D8C8DEC1
D9FAD9C0DC4C2418DD5C2408DC4C2420DC8F70FFFFFFD9EADEC9D9E8D9C1D9F8
D9F0DEC1D9FDD9C9DDD8DD1424DD442408DC8F70FFFFFFD9EADEC9D9E8D9C1D9
F8D9F0DEC1D9FDD9C9DDD8DD542408DEC9DD5C2418DD0424D8C8DD442408D8C8
DEC1DD5C2420DD442418D8C8D9E8DEC1DD5C2428DD442410D9FEDC4F80DC4C24
18D9EED8D99BDFE0D0EC730ADC442420DC742428EB0CD9E0DC442428DD442420
DEF1D9EAD9C9D9F1DCB770FFFFFFD9E1DCA778FFFFFFDC0F837FBC007503DC77
E0DD5EE0DD47F0DB46E8DC4FB4DEC1D9E1DD9E8000000083C464C3
[END]

An enhanced version of the  famous Scherk's minimal surface, that 
is defined, in its classic version, by the simple and elegant
implicit equation in terms of cartesian x,y,z;

sin(z) = sinh(x)sinh(y)

This surface can be seamlessly "tiled" if you replace x with k*sin(x),
and y with k*sin(y) with a k > 0.5 for a best effect.
(I am pretty sure the surface isn't minimal anymore, but it still looks
very elegant).

Lots of beautiful variations can be visualized with other coordinate
transforms on x,y,z (like toroidal), and you can see some examining the site

https://wewanttolearn.wordpress.com/2015/11/11/scherks-minimal-surface/

// ----------------------------------------------------------------

To get a linearized, continuous DE you may try this algorithm;

float ScherkDe(float x, float y, float z) // (by Luca GN 2016)
 {
  float Ex=exp(x); float Ey=exp(y); float zz=Ex*Ey;
  float N = Ex*Ex+Ey*Ey;
  float D = 1+zz*zz;
  zz = 4.*sin(z)*zz; // can be + or - or change 4 to get elliptic holes
  if (zz>0) N += zz else D -= zz; // we bring it to the correct eq side :)
  return .5*(abs(log(N/D))-.05); // give it a little thickness so it renders better
}